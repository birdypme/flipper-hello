#include <furi.h>
#include <furi_hal.h>

#include <gui/gui.h>
#include <input/input.h>

/* generated by fbt from .png files in images folder */
#include <hello_icons.h>

typedef struct {
    uint8_t x;
    uint8_t y;
} Position;

typedef struct {
    bool displayed;
    Position position;
    const Icon* image;
} Entity;

void entity_reset(Entity* entity) {
    entity->displayed = false;
    entity->position.x = 0;
    entity->position.y = 0;
    entity->image = NULL;
}

typedef struct {
    Entity rabbit;
    Entity hello;
    int hello_time;

    FuriMessageQueue* message_queue;
    ViewPort* view_port;
    Gui* gui;
} AppState;

void appstate_reset(AppState* app_state) {
    entity_reset(&app_state->rabbit);
    entity_reset(&app_state->hello);
    app_state->hello_time = 0;
    app_state->message_queue = NULL;
    app_state->view_port = NULL;
    app_state->gui = NULL;

    app_state->rabbit.displayed = true;
    app_state->rabbit.image = &I_rabbit;
    app_state->hello.image = &I_hello;
}

void draw_entity(Canvas* canvas, Entity* entity) {
    if(!entity->displayed) {
        return;
    }
    if(entity->image == NULL) {
        return;
    }
    canvas_draw_icon(canvas, entity->position.x % 128, entity->position.y % 64, entity->image);
}

void on_draw(Canvas* canvas, void* ctx) {
    furi_assert(ctx);
    AppState* app_state = (AppState*)ctx;

    canvas_clear(canvas);
    draw_entity(canvas, &app_state->rabbit);
    draw_entity(canvas, &app_state->hello);
}

void on_input(InputEvent* input_event, void* ctx) {
    furi_assert(ctx);
    AppState* app_state = (AppState*)ctx;

    furi_message_queue_put(app_state->message_queue, input_event, FuriWaitForever);
}

void init_gui(AppState* app_state) {
    app_state->message_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    // Configure viewport
    app_state->view_port = view_port_alloc();
    view_port_draw_callback_set(app_state->view_port, on_draw, app_state);
    view_port_input_callback_set(app_state->view_port, on_input, app_state);

    // Register viewport in GUI
    app_state->gui = (Gui*)furi_record_open(RECORD_GUI);
    gui_add_view_port(app_state->gui, app_state->view_port, GuiLayerFullscreen);
}

void destroy_gui(AppState* app_state) {
    view_port_enabled_set(app_state->view_port, false);
    gui_remove_view_port(app_state->gui, app_state->view_port);
    view_port_free(app_state->view_port);
    app_state->view_port = NULL;
    furi_message_queue_free(app_state->message_queue);
    app_state->message_queue = NULL;

    furi_record_close(RECORD_GUI);
    app_state->gui = NULL;
}

bool process_message(AppState* app_state, InputEvent* input_event) {
    if((input_event->type == InputTypePress) || (input_event->type == InputTypeRepeat)) {
        switch(input_event->key) {
        case InputKeyLeft:
            app_state->rabbit.position.x -= 2;
            return true;
        case InputKeyRight:
            app_state->rabbit.position.x += 2;
            return true;
        case InputKeyUp:
            app_state->rabbit.position.y -= 2;
            return true;
        case InputKeyDown:
            app_state->rabbit.position.y += 2;
            return true;
        case InputKeyOk:
            app_state->hello_time = 10;
            app_state->hello.displayed = true;
            app_state->hello.position.x = app_state->rabbit.position.x + 16;
            app_state->hello.position.y = app_state->rabbit.position.y;
            return true;
        default:
            // could be app_state->running = false;
            return false;
        }
    }
    return true;
}

void main_loop(AppState* app_state) {
    InputEvent input_event;

    bool running = true;
    while(running) {
        int result = furi_message_queue_get(app_state->message_queue, &input_event, 100);
        if(result == FuriStatusOk && !process_message(app_state, &input_event)) {
            break;
        }
        if(app_state->hello_time > 0) {
            app_state->hello_time = app_state->hello_time - 1;
        }
        if(app_state->hello_time <= 0) {
            app_state->hello.displayed = false;
        }
        view_port_update(app_state->view_port);
    }
}

static AppState g_app_state;

int32_t hello_app(void* p) {
    appstate_reset(&g_app_state);

    UNUSED(p);
    FURI_LOG_I("TEST", "Hello world");

    init_gui(&g_app_state);
    main_loop(&g_app_state);
    destroy_gui(&g_app_state);

    return 0;
}
